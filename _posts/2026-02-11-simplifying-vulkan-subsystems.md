---
layout: post
title: "逐步简化 Vulkan：从子系统重构开始"
date: 2026-02-11 05:45:30 +0800
categories: tech-translation
description: "Khronos Vulkan 工作组通过全新的子系统替换方式来解决扩展爆炸问题，VK_EXT_descriptor_heap 是首个完整重构的实践。"
original_url: https://www.khronos.org/blog/simplifying-vulkan-one-subsystem-at-a-time
source: Hacker News
---

本文翻译自 [Simplifying Vulkan One Subsystem at a Time](https://www.khronos.org/blog/simplifying-vulkan-one-subsystem-at-a-time)，原载于 Khronos Group 官方博客。

## 前言

当我们 Vulkan 工作组的成员想要修改 API 时——无论是要暴露新的硬件特性、支持新的用例，还是仅仅要弥补规范中的某个缺口——我们都有一个无价的工具，而且我们一直在大量使用它：**扩展（Extensions）**！

扩展是一种极好的方式，让我们能够将 Vulkan API 的改进快速送到开发者手中，而无需等待新的核心版本发布。它让供应商能够暴露新颖的功能，也让我们在将新功能固化为核心规范之前能够收集社区的反馈。

太棒了！我们可以快速向开发者推出新功能——这有什么不喜欢的呢？嗯……

## 扩展爆炸问题 💥

拥有如此强大的扩展性是有代价的。随着我们向 API 添加越来越多的扩展，有时我们会无意中掩盖使用它的最简单方式。哪些功能你可以放心地认为一定存在？有多少种方法可以完成你想做的事情？哪种方式能提供最佳性能？在一个应用中你能合理地支持多少条 API 路径？

由于我们现在拥有的扩展数量之多——以及在 OpenGL/ES 之前存在的扩展数量——我们有时_亲切地_称之为"扩展爆炸问题"。我们添加的越多，它们之间的链式依赖和交互就越多，为开发者的决策空间呈组合级数增长。

这是我们从 Vulkan 开发者群体中听到的一个持续挑战，但直到现在我们还没有一个好的解决方案。

当我们发布 Vulkan 1.0 时，它给了我们从 OpenGL 转变的一个干净起点，但现在 Vulkan 问世 10 年后，我们再次面临同样的问题。那么，答案是什么？我们应该每隔几年就从头重建整个 API 吗？

不——信不信由你，__我们要添加更多扩展__！

……🤨？

## 子系统替换

虽然看起来反直觉，但添加更多扩展确实是我们改进状况的一种方式。然而，这__不能__是照常营业。我们__必须__采取不同的方法。

而不是增量式地添加或更改 API 并增加复杂性，我们希望修订整个 API 子系统，产生完整的替换品，让你可以忽略之前的一切，并有支持的工具和行业支持来确保新方法无处不在地推出。

**VK_EXT_descriptor_heap** 是这种方法的首次具体尝试，__完全替换__了 Vulkan 中现有的描述符集（descriptor set）子系统。Vulkan 工作组的成员为此倾注了所有心血，它受到了我们通常只在重大 API 修订（如 Vulkan 1.0）中才能看到的那种关注。虽然它目前作为 EXT 发布，但它非常有可能成为未来的核心功能。

我们之前曾尝试用 VK_EXT_descriptor_buffer 来修复描述符模型，开发者们取得了一些成功，但我们对现有的描述符集功能使用了增量式（虽然很大！）的改进，这使得必须检查各种描述符集扩展。这种增量方法也没有吸引广泛的行业支持，导致跨供应商的可移植性问题。我们知道我们拥有重要东西的核心，但它需要重新思考才能坚持下去。因此，我们吸取了 VK_EXT_descriptor_buffer 的经验教训，设计了一个全新的子系统。

新的 VK_EXT_descriptor_heap 扩展与之前的描述符集 API（包括布局、推送描述符或描述符缓冲区）__完全不交互__——它完全替换了所有这些。这个扩展不仅仅是试图稍微清理一下 API，它从根本上改变了 Vulkan 应用程序与描述符的交互方式。描述符不再是你通过一系列笨拙的 API 命令和限制性着色器绑定来管理的某种不透明的东西。描述符堆只是内存，描述符只是数据，你可以__或多或少__地对它们做任何你想做的事情。__有一些__限制，但它更接近你在游戏主机上可能期望的，而不是在可移植 API 中。

这个扩展也有来自行业巨大范围的贡献，比我们典型的扩展多得多。请随时查看贡献者列表——它__非常广泛__。这个扩展几乎得到了 Vulkan 工作组中每个人的有意义的投入。我们一起在过去三年的大部分时间里进行迭代和改进，确保它不仅工作有效，而且工作__良好__。

## 既然有这么多的支持，为什么不是 KHR？

__我们也想确保得到你的支持。__

对于如此大的东西，我们要确保把它做对。我们相信我们构建的已经是巨大的改进和出色的功能，但通过将其作为 EXT 发布，我们给更广泛的社区一个尝试的机会，弄清楚其复杂性，或许建议如何使其更好。

EXT 不会改变，所以你今天就可以在发布的应用程序中使用它；当我们最终发布 KHR 版本时，如果你选择使用它，我们的目标是让转换尽可能简单。

如果你确实在新扩展中发现任何你认为可以简化或改进的地方，我们在最终确定 KHR 规范时会考虑任何反馈。通过这样做，我们将努力使所有内容尽可能完善，避免以后添加额外的扩展来修复问题。

虽然我们无法保证最终的 KHR 何时会实现，但在接下来的 9 个月内获得反馈将给我们最好的机会来整合你的意见。

请__使用这个扩展并让我们知道进展如何__！

## 很好。你们对描述符做了点什么。那 <插入功能> 呢？

开发者需求是我们路线图规划的核心，我们致力于解决我们听到的请求。__很有可能我们已经在处理你追求的东西__。

如果我们没有在某处记录你的问题，或者你认为它没有得到足够的关注，我们鼓励你加入我们的 Discord 或在 GitHub 上提交问题，让我们知道！

为了像这样替换子系统，我们要平衡很多考虑——开发者需求、生态系统需求、供应商路线图、未来方向，以及即将推出的硬件和软件发布等等。照顾所有这些需求需要谨慎，试图第一次就做对。但这并不意味着任何这些都需要缓慢！我们正在积极研究如何使用这种方法来升级 Vulkan API 的关键部分，并有强大的行业支持。

我们现在的首要任务之一是让 Vulkan API 成为一种使用乐趣。我们知道我们还有很长的路要走，但我们希望像这样经过深思熟虑的子系统替换是朝这个方向迈出的积极一步。请让我们知道你对这种方法的看法——我们很乐意听到你的意见！