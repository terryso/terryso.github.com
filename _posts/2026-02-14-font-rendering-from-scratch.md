---
layout: post
title: "字体渲染技术深度解析：从 TTF 到 SDF"
date: 2026-02-14 13:36:12 +0800
categories: tech-translation
description: "深入探讨字体渲染的技术原理，从 TTF 文件格式解析到字形栅格化，再到 SDF（Signed Distance Field）渲染技术的完整实现流程。"
original_url: https://mccloskeybr.com/articles/font_rendering.html
source: Hacker News
---

本文翻译自 [Font Rendering - mccloskeybr.com](https://mccloskeybr.com/articles/font_rendering.html)，原载于 Hacker News。

---

字体渲染是一项我们习以为常的技术——很难想象没有它我们该如何与计算机交互。但这到底有多难呢？事实证明，比你想象的要难得多：

- 文本可以以任意尺寸渲染。字体数据是如何编码的，才能让字形在任何目标分辨率下都保持高质量？
- 字体通常是曲线的，而像素不是。我们该如何对字形进行抗锯齿处理以保持文本的视觉美感？
- 我们如何设计一个尊重不同语言不同布局规则的系统（例如英语 vs 阿拉伯语）？

看看 FreeType（GPL 许可，用于 Chromium、GNU/Linux 等），他们声称代码量超过 20 万行。

我决定自己动手实现。在这篇文章中，我将详细介绍 TTF 文件规范和我的实现过程。

## 为什么要自己实现？

为什么不用 FreeType 或其他现成的库？自己实现有什么好处？

1. **深入理解基础技术** - 对支撑我们使用互联网等的基础技术有更深的认识。没有它，你现在就读不到这篇文章。
2. **建立直觉** - 了解渲染网页/GUI 所需的工作量。为什么字体缓存很重要？如何降低渲染时间？
3. **扩展能力** - 对基础有深刻理解后可以进行扩展。例如通过 SDF 添加程序化边框。
4. **有趣** - 为什么不呢？我们是娱乐编程的粉丝。

## TTF 文件格式

在开始渲染字符串之前，我们首先需要读取字体数据。我的实现专注于 TTF（TrueType）文件格式。另一种常用的格式 OTF（OpenType）可以看作是 TTF 的超集（还包括 PostScript 字体），所以如果你想渲染 OTF 字体，反正也得先做一个 TTF 解析器。

从高层次来看，TTF 文件提供了字符码点到字形信息的某种映射。

### 什么是码点（Codepoint）？

字符的"码点"指的是它的 Unicode 编码格式。你可能熟悉 ASCII 编码，它是拉丁字母表中每个字符的单字节表示（例如，字符 'A' 映射到 65，'z' 映射到 122 等）。ASCII 的一个主要限制是它没有提供足够的空间来描述非拉丁语言。Unicode 是解决这个问题的国际标准方案。

Unicode 有多种编码格式，例如 UTF-8 和 UTF-32；它们的唯一区别是如何编码这个码点（UTF-32 总是用 4 字节表示码点，UTF-8 使用可变长度）。方便的是，UTF-8 与 ASCII 向后兼容（感谢 Ken Thompson 和 Rob Pike）。由于我目前只专注于拉丁字母表，这意味着 'a' 的码点可以通过 `(uint8_t)('a')` 来获取。

### 什么是字形（Glyph）？

字形只是对字母和字符的抽象。TTF 文件不知道字母 'a' 是什么，它只是某个值（Unicode 码点）到该值相关数据（字形）的不透明映射。这包括与该线条相关的实际点和曲线，以及我们需要小心考虑的关于该字符的额外度量信息。

看看这张图片的例子：

![字形度量示例](https://mccloskeybr.com/articles/font_rendering.html)

这里，同一个字符串被渲染了两次（下面：可读的字符串，上面：每个字形的纹理完全不透明）。观察字形之间的差异——中心如何相对于基线定位，字符之间添加了多少空间——所有这些都高度依赖于你尝试渲染的字体和字符。

### TTF 文件结构

TTF 文件本身的结构并不太复杂；有多个表包含构成整个字体的各个字形的不同信息。只有少数几个表是直接相关的：

- `glyf`：存储字形形状数据
- `loca`：将字形索引映射到 `glyf` 表中的偏移量
- `cmap`：将 Unicode 码点映射到字形索引

从这个结构，我们可以开始了解如何获取字体形状信息。对于我们想要渲染的每个字符：

1. 通过 `cmap` 表确定其字形索引
2. 通过在 `loca` 表中查找其对应值来确定字形数据在文件中的位置
3. 在 `glyf` 表中提取字体形状信息

还有一些其他有用的表：

- `head`：包含关于字体的全局信息
- `maxp`：描述字体中某些参数的最大值（例如"这个字体包含多少个字形？"），对边界检查有用
- `hhea`：包含关于水平字体的信息，包含 `ascent` 和 `descent` 变量，用于确定字体的总垂直大小
- `hmtx`：描述每个字形水平布局的表（例如字形的 `advance`）
- `kern`：可选提供的表，描述字符对的额外字距调整信息

## 字形解析

现在我们知道字形数据在哪里了，是时候解析它了。

TTF 字形由一系列轮廓（contours）组成，这些轮廓本身被描述为一系列二次贝塞尔曲线。这些曲线由 3 个点组成：起点、终点和"控制点"。

贝塞尔曲线被形式化定义为这些点的"线性组合"（`起点 -> 控制点 -> 终点`），其中，给定 `[0, 1]` 范围内的 `t`，计算点对之间的线性插值，递归进行，直到塌缩到单个点。

另一种描述二次贝塞尔曲线的方式是通过公式：`(((1-t)^2) * P_start) + (2(1-t)t * P_control) + ((t^2) * P_end)`

这些曲线被组合形成轮廓，轮廓被组合形成整体字形形状。作为例子，这是 Consola 字体中描述字形 'B' 的轮廓，每个轮廓是不同的颜色（注意贝塞尔控制点用紫色着色）：

![字形轮廓示例](https://mccloskeybr.com/articles/font_rendering.html)

我们看到，在这种情况下，有 3 个独立的轮廓：一个用于"外壳"，两个用于要从中切出的"孔"。TTF 规范要求这些类别的轮廓必须单独定义——"外壳"轮廓点的顺序必须是顺时针的，"孔"轮廓点必须是逆时针的。稍后在栅格化字形时，我们将使用此信息来知道我们何时进入或退出形状。

TTF 将二次贝塞尔点存储在一组连续数组中，解析后会塌缩为一个简单的结构：

```c
struct GlyphPoint {
    B8 on_curve;  // 如果为 false，这个点是控制点
    V2 position;  // 点的校正位置（最初作为与前一个点的增量提供）
};
```

接下来，我们需要解开 TTF 对点数据应用的一些压缩。有时，它会从流中省略点——我们需要把它们加回去。预期的点流看起来像：`点（在曲线上） -> 点（离曲线） -> 点（在曲线上） -> 重复`。但实际提供的数据流中，我们经常遇到`点（离曲线） -> 点（离曲线）`这样的情况——我们该怎么办？

在这些场景中，一个在曲线上的点被_隐含_在这些离曲线点的中点，我们需要自己添加它。此外，规范还会给你像 `点（在曲线上） -> 点（在曲线上）` 这样的情况——这里没有什么技巧，这只是这两点之间的直线，这只是另一个需要注意的情况，与二次贝塞尔情况不同。

我选择将其建模为：

```c
struct GlyphCurve {
    V2 point;    // 这条曲线的起点
    V2 control;  // 控制点
};
```

其中贝塞尔曲线的终点被隐含为轮廓中下一条贝塞尔曲线的起点。

## 字形栅格化

有了形状，是时候进行栅格化了。算法大致如下：

1. **确定目标位图区域** - 你可以为每个字符生成单独的位图，但生成包含所有字符的图集（atlas）可能更高效/优化，稍后在向 GPU 发出绘制调用时索引到其中。这就是我所做的。

2. **对于每一行（y 值）** - 确定字形空间中对应的 y 值。这可以通过两个空间之间的简单线性映射来完成。

3. **确定 x 交点** - 通过求解二次贝塞尔公式中的 `t` 来完成——当 `0 <= t <= 1` 时，我们有一个交点。注意！求解二次方程涉及除以某个变量值，这可能是 0——这些情况描述的是秘密地是直线的贝塞尔曲线。

4. **确定进入或离开** - 通过查看我们相交的贝塞尔曲线的导数，我们可以确定我们是在进入（y 值增加）还是离开（y 值减少）形状。Apple 规范建议在我们遇到交点时累积一个运行的缠绕计数——这通过根据我们是进入还是离开形状为我们遇到的每个交点 +/- 1 来实现。当缠绕顺序 > 0 时，画笔应该落下，我们应该绘制。否则，画笔应该抬起。

5. **栅格化** - 现在我们有了所有需要的信息，我们可以索引到目标位图中并根据每个 x 值是在形状内部还是外部来着色。

结果如何？看起来很糟糕...为什么？据我所知，这有几个原因：

1. 缺乏抗锯齿
2. TTF 字体有关于如何以各种大小渲染位图的额外指令，我们现在故意忽略
3. 位图字体不能很好地缩放

## SDF 字形渲染

我们可以采取多种选项来纠正我们次优的字体栅格（MSDF 是我考虑的另一个选项，你也可以看看子像素渲染）。我选择为字形生成 SDF，这很有吸引力，因为作为对已经实现的内容的额外步骤相当简单。

首先，什么是 SDF？它如何解决我们的问题？

SDF 代表"有符号距离场"（Signed Distance Field）。SDF 可以描述为任意形状的函数表示，确定到该形状边缘的距离（"有符号"来自这个值在形状内部为负，在形状外部为正）。

对于字体渲染，我们不是为目标位图中的每个像素计算二进制的"这是在里面还是外面"的决定，而是确定从该像素到相反状态的最近点（绘制或未绘制）的距离。这提供了沿着形状边缘的"内部程度"的平滑渐变，我们可以利用 GPU 快速高效地大规模插值值的能力，以比原始位图表示更广泛的分辨率范围渲染字体字符。

这是字母 'B' 的 SDF。注意当我们沿着字母的硬边缘进一步延伸时，字母周围有一个渐变——我们可以用它来对抗锯齿原始位图。

### 生成 SDF

根据 Valve 关于这个主题的论文：

1. **生成字形的位图** - 这完全重用了我们之前实现的内容。根据我的经验，栅格化一个相对较大的位图在这里很重要，以便为后续步骤提供高水平的粒度。本质上，分辨率越高，后面的距离测量就越准确，从而产生更高质量的结果。我默认使用 64 的位图字体高度。

2. **确定 SDF 栅格在目标位图中的位置** - 类似于位图栅格化。

3. **确定最近像素** - 对于 SDF 目标位图中的每个像素，我们需要确定原始位图中哪个像素最近。

4. **计算距离** - 对于目标 SDF 位图中的每个像素，确定到原始字形位图中相反状态像素的最近距离。这可以通过选择某个"扩散因子"（内核大小）并在目标像素周围搜索该大小的正方形来完成。这个参数是可调的，我发现值 4 在这里是合理的。

5. **映射并保存** - 将距离映射到字节范围 [0, 255] 并将其保存到 SDF 图集。

### 使用着色器渲染

这里生成的 SDF 位图本身并不用于渲染——这些更好地描述为每个候选字形 SDF 函数值的缓存。所以，我们需要额外的指令来说明如何将这些距离值转换为我们可以绘制到屏幕的实际位图。

我为此目的制作了一个着色器（OpenGL）。更有趣的是片段着色器：

```glsl
#version 330 core
uniform sampler2D atlas_image;
uniform vec3 text_color;
uniform float threshold;
uniform float smoothing;

in vec2 glyph_tex_coord;
out vec4 frag_color;

void main() {
    float dist = texture(atlas_image, glyph_tex_coord).r;
    float alpha = smoothstep(threshold - smoothing, threshold + smoothing, dist);
    frag_color = vec4(text_color, alpha);
}
```

你会看到我们为渲染的每个给定像素提取缓存的距离值，应用一些 smoothstep 来确定 alpha，在最终像素颜色中使用结果。简单来说，这确定了沿着 SDF 周围的"内部程度"场的哪个距离我们实际上认为在该字符的内部和外部。这由 2 个参数控制：`threshold`（阈值），它是入/出的切割点；`smoothing`（平滑），它在阈值上应用一些渐进过渡/模糊。

结果如何？好多了。

## 总结

通过自己实现字体渲染，我们深入了解了：

1. **TTF 文件格式** - 理解 `glyf`、`loca`、`cmap` 等表的作用
2. **贝塞尔曲线** - 二次贝塞尔曲线如何构成字形轮廓
3. **栅格化算法** - 从矢量形状到像素的转换过程
4. **SDF 技术** - 如何使用有符号距离场实现高质量的字体渲染

最终的结果相当不错。这种技术可以用于渲染 UI 控件、游戏中的文本等场景。虽然 SDF 在大字体尺寸下会有一些伪影，但可以通过以更高分辨率渲染 SDF 图集来纠正，只是会带来更高的内存成本。

## 延伸阅读

如果你想学习如何自己实现字体渲染，我推荐以下资源：

- Sebastian Lague 的视频：[Coding Adventure: Rendering Text](https://www.youtube.com/watch?v=SO63p6LQjqQ)
- Sphaerophoria 的视频系列
- Tsoding 的视频：[Rasterizing Splines in C (from fundamentals)](https://www.youtube.com/watch?v=YTg7JpZc6Ew)
- [stb_truetype 实现](https://github.com/nothings/stb/blob/master/stb_truetype.h)

---

> 本文介绍了从零开始实现字体渲染的完整过程。对于想深入理解图形渲染基础的开发者来说，这是一个很好的学习项目。SDF 技术不仅适用于字体渲染，还可以用于各种 2D/3D 形状的高质量渲染。
