---
layout: post
title: "Apple Clutch 调度器：XNU 内核的多核调度设计解析"
date: 2026-02-09 09:28:40 +0800
categories: tech-translation
description: "深入解析 Apple XNU 内核中的 Clutch 和 Edge 调度器设计，了解 iOS/macOS 如何在多核异构平台上实现高效的线程调度"
original_url: https://github.com/apple-oss-distributions/xnu/blob/main/doc/scheduler/sched_clutch_edge.md
source: GitHub
---

本文翻译自 [Clutch Scheduler](https://github.com/apple-oss-distributions/xnu/blob/main/doc/scheduler/sched_clutch_edge.md)，原文来自 Apple 开源发布的 XNU 内核文档。

## 背景介绍

XNU 内核运行在各种平台上，对动态性和效率有着强烈的要求。它需要满足广泛的需求：从延迟敏感工作负载（如 UI 交互、多媒体录制/播放）的快速 CPU 访问，到低优先级批处理工作负载（如照片同步、源代码编译）的饥饿避免。传统的 Mach 调度器通过期望系统中所有线程都标记有优先级数字，并将高优先级线程视为交互式线程、低优先级线程视为批处理线程来实现这些目标。然后，它使用基于优先级衰减的分时模型来惩罚使用 CPU 的线程，以实现公平共享和饥饿避免。

然而，这种方法丢失了线程与更高级别用户工作负载之间的关系，使得调度器无法从整体上推理工作负载——而这正是最终用户所关心的。这种基于线程的分时方法的一个副作用是，同一优先级的线程被同等对待，无论它们服务于哪个用户工作负载，这通常导致非最优决策。最终导致整个平台的优先级膨胀，各个子系统提高自己的优先级以避免与其他不相关线程的饥饿和分时。

传统的线程级调度模型还存在以下问题：

* **不准确的计算**：线程级别的 CPU 计算激励系统创建更多线程。在 GCD 和工作队列的世界中，线程被快速创建和销毁，线程级计算不准确，允许过度的 CPU 使用。
* **隔离性差**：在 Mach 调度器中，分时通过根据全局系统负载衰减线程的优先级来实现。这种属性可能导致相同或较低优先级带的突发活动导致 App/UI 线程的衰减，从而导致性能和响应能力差。调度器在处理延迟敏感的 UI 工作负载的线程和执行大批量非延迟敏感操作的线程之间提供非常有限的隔离。

## Clutch 调度器设计

为了推理更高级别的用户工作负载，Clutch 调度器调度线程组而不是单个线程。脱离传统的单层调度模型，它实现了一个分层调度器，在各种线程分组级别做出最优决策。如今实现的分层调度器有 3 个级别：

* 调度桶级别（Scheduling Bucket Level）
* 线程组级别（Thread Group Level）
* 线程级别（Thread Level）

### 调度桶级别

最高级别是调度桶级别，它决定应该选择哪类线程执行。内核为每个线程维护一个调度桶的概念，这些桶基于线程的基础/调度优先级定义。这些调度桶大致映射到 OS 运行时用来定义各种工作性能期望的 QoS 类。具有相同调度桶的所有可运行线程在此级别由单个条目表示。这些条目在整个实现中被称为**根桶**。此级别的目标是为高 QoS 类提供对 CPU 的低延迟访问，同时确保低 QoS 类的饥饿避免。此级别还为此层次结构和集群绑定的线程维护单独的根桶，允许调度器在各种 QoS 级别的绑定和未绑定线程之间有效地分时。

**实现原理**

调度桶级别使用最早截止时间优先（EDF）算法来决定下一个应该选择哪个根桶执行。每个具有可运行线程的根桶都表示为优先级队列中的一个条目，该队列按桶的截止时间排序。桶选择算法只是选择优先级队列中截止时间最早的根桶。根桶的截止时间基于其首次可运行时间戳和**最坏情况执行延迟（WCEL）**值计算，该值是每个桶预定义的。WCEL 值基于 Mach 分时算法遵循的衰减曲线选择，以允许系统从更高级别的角度与现有调度器类似地运行。

```c
static uint32_t sched_clutch_root_bucket_wcel_us[TH_BUCKET_SCHED_MAX] = {
  SCHED_CLUTCH_INVALID_TIME_32,    /* FIXPRI */
  0,                               /* FG */
  37500,                           /* IN (37.5ms) */
  75000,                           /* DF (75ms) */
  150000,                          /* UT (150ms) */
  250000                           /* BG (250ms) */
};
```

每当根桶从不可运行转换为可运行时，其截止时间设置为 `(now + WCEL[bucket])`。这确保即使在重负载系统中，桶也会在 WCEL[bucket] 被调度。一旦选择了根桶执行，其截止时间会被 WCEL[bucket] 推迟到未来。这种 EDF 的基本实现存在一个主要问题：在重负载系统中，较高桶可能在最近过去使用了足够的 CPU，以至于它们在截止时间顺序上落后于较低桶。现在，如果一小批用户关键工作负载出现，高桶必须等待较低桶运行才能获得 CPU，这可能导致性能问题。

为了解决这个问题，桶级调度器实现了根桶"跃迁"（warp）机制。每个桶都有一个跃迁值，当桶因截止时间到期而被选中时刷新。

```c
static uint32_t sched_clutch_root_bucket_warp_us[TH_BUCKET_SCHED_MAX] = {
  SCHED_CLUTCH_INVALID_TIME_32,    /* FIXPRI */
  8000,                            /* FG (8ms)*/
  4000,                            /* IN (4ms) */
  2000,                            /* DF (2ms) */
  1000,                            /* UT (1ms) */
  0                                /* BG (0ms) */
};
```

根桶选择逻辑找到截止时间最早的桶，然后检查是否有任何更高（按自然优先级顺序）桶有剩余跃迁。如果有这样的较高桶，它将选择该桶并有效地打开跃迁窗口。在此跃迁窗口期间，调度器将继续选择此跃迁桶而不是较低优先级的桶。一旦跃迁桶耗尽或跃迁窗口到期，调度器将恢复按截止时间顺序调度桶。这种机制为高级别桶提供了有界的优势，允许它们在突发工作负载存在时保持响应。

`FIXPRI` 桶是特殊处理的，因为它包含极其延迟敏感的线程。由于 `FIXPRI（即 AboveUI）` 和 `FG Timeshare` 桶的优先级范围重叠，因此在这些桶之间保持一些原生优先级顺序很重要。这里实现的策略是比较两个桶的最高 Clutch 桶；如果 Above UI 桶更高，则立即调度它，否则回退到上述基于截止时间的调度。该实现为 Above UI 线程提供了极低的延迟 CPU 访问，同时支持高优先级分时线程与较低优先级固定优先级线程竞争的用例，这在某些媒体工作负载中观察到。

由于分时桶在消耗 CPU 时最终会降低优先级，此模型为高于 UI 的分时线程提供了所需的行为。

### 线程组级别

第二级是"线程组"级别，它决定应该选择 QoS 桶中的哪个线程组执行。线程组代表代表特定工作负载的线程集合。此级别的目标是在各种用户工作负载之间共享 CPU，优先考虑交互式应用程序而不是计算密集型批处理工作负载。

**实现原理**

线程组级别实现了 FreeBSD ULE 调度器的变体，以决定下一个应该选择哪个线程组执行。QoS 桶中每个具有可运行线程的线程组使用 `struct sched_clutch_bucket_group` 表示。对于多集群平台，`sched_clutch_bucket_group` 表示平台上所有集群上排队的线程。Clutch 桶组维护 CPU 使用历史、可运行历史以及下一级调度器的一些分时信息。

Clutch 桶组有一个条目来表示平台上每个集群的线程组的可运行线程。此条目是 `sched_clutch_bucket`，此级别的算法试图找到每个根层次结构上调度的最佳 Clutch 桶。每个具有可运行线程的 Clutch 桶都表示为运行队列中的一个条目，该运行队列按 Clutch 桶优先级排序。Clutch 桶选择算法只是选择 Clutch 桶运行队列中优先级最高的 Clutch 桶。Clutch 桶的优先级计算基于以下因素：

* **Clutch 桶中最高可运行线程**：Clutch 桶维护一个优先级队列，其中包含按提升优先级或基础优先级（无论哪个属性使线程有资格成为该 Clutch 桶的一部分）排序的线程。它使用这些线程中最高的线程来计算 Clutch 桶的基础优先级。同时使用基础优先级和调度优先级允许调度器遵守通过 SPI 从用户空间指定的优先级差异、由于优先级继承机制（如旋转门）和其他影响优先级的机制（核心调度器之外）导致的优先级提升。

* **交互性得分**：调度器基于 Clutch 桶组整体的自愿阻塞时间和 CPU 使用时间的比率计算交互性得分。此得分允许调度器优先考虑高交互性线程组，而不是批处理计算密集型线程组。

### 线程级别

在最低级别，调度器决定应该选择 Clutch 桶中的哪个线程执行。Clutch 桶中每个可运行线程都表示为运行队列中的一个条目，该运行队列基于线程的 `sched_pri` 组织。线程选择算法只是选择运行队列中优先级最高的线程。线程的 `sched_pri` 计算基于传统的 Mach 调度算法，该算法使用负载和 CPU 使用来衰减线程的优先级。与全局调度器相比，线程衰减模型在此级别更合适，因为负载计算仅考虑同一 Clutch 桶组中的线程。由于同一 Clutch 桶组中的所有线程都属于同一线程组和调度桶，因此该算法为 Clutch 桶组中的延迟敏感线程提供快速 CPU 访问，而不会影响系统中其他不相关的线程。

## Edge 调度器设计

Edge 调度器实现了在多集群异构平台上调度所需的所有必要功能。在每个集群上，它使用上述 Clutch 调度器分时设计。在线程放置和负载平衡方面，Edge 调度器将机器表示为图，其中每个节点是一个计算集群，有向边描述从一个集群到另一个集群迁移线程的可能性。Edge 调度器与性能控制器密切合作以定义各种调度策略。

### Edge 调度器系统目标

* 系统应该是**紧凑的**。尽可能将小宽度工作负载线程限制在单个集群中。这种属性重要的原因：
  * 更好的 LLC 使用。
  * 通过避免昂贵的集群间、芯片间缓存填充来提高性能
  * 电源门控或关闭未使用的 ACC

* 如果工作负载可以使用，**快速打开集群**（例如，为了并行性，减轻乘客效应），原因如下：
  * 没有暗硅
  * 效率核心为基准测试以及吞吐量导向的工作负载提供有意义的性能提升

* 允许高 QoS 工作**低延迟访问 CPU**。此属性确保高 QoS 线程即使在重 CPU 争用下也能体验低调度延迟。

* **仅"向下"迁移**。线程应该迁移到执行效率不会明显更差的集群。这可能是打开新集群的原因（与保持系统紧凑的第一个系统目标相反）。

* 管理**乘客效应**。当共享一个集群的工作负载的期望性能开始分歧时，一些将支付"乘客税"。在这种情况下，希望拆分工作负载以确保平台上的最高效执行。

* 适应**快速变化的工作负载宽度**。

### Edge 调度器线程放置策略

Edge 调度器使用性能控制器的**每个线程组建议**和调度器中的**每个集群运行队列**。该设计旨在为性能控制器提供影响系统宽度（就集群数量而言）的能力，同时保留调度器在线程风暴期间扩展的能力。

### 线程迁移策略

为了选择可运行线程的集群和处理器，edge 调度器使用线程的 `sched_clutch_bucket_group` 的首选集群。如果首选集群空闲或运行较低 QoS 的工作负载，调度器只需选择首选集群来排队线程。否则，调度器评估从首选集群出发的出边以进行迁移决策。

**Edge 调度器边矩阵**

Edge 调度器维护一个线程迁移图，其中每个节点代表一个集群，每个有向边代表跨该边迁移线程的可能性。每个图边编码以下属性：

```c
typedef union sched_clutch_edge {
  struct {
    uint32_t
    /* boolean_t */ sce_migration_allowed : 1,
    /* boolean_t */ sce_steal_allowed     : 1,
                    _reserved             : 30;
    uint32_t        sce_migration_weight;
  };
  uint64_t sce_edge_packed;
} sched_clutch_edge;
```

` sce_migration_allowed` 和 `sce_steal_allowed` 标志指示是否允许跨边迁移和窃取线程。`sce_migration_weight` 是应该存在于源节点和目标节点（即集群）之间的调度延迟增量的度量，以使线程被迁移。

### 线程窃取/重新平衡策略

当处理器在其运行队列中找不到任何线程执行时，会调用 `SCHED(steal_thread)` 调度器调出。窃取操作的目的是找到在其他集群中运行/可运行的其他线程，这些线程应该在此处执行。如果窃取调出不返回线程，`thread_select()` 逻辑会调用 `SCHED(processor_balance)` 调出，该调出应该向其他 CPU 发送 IPI 以重新平衡线程并使当前 CPU 空闲，等待 IPI'ed 线程将线程重新调度到此 CPU。

**Edge 调度器外来线程**

当这些 Clutch 桶在与线程组的首选集群不对称的集群上排队时，Edge 调度器将 Clutch 桶（以及相应地 Clutch 桶中的线程）识别为外来。外来 Clutch 桶是 Clutch 根的常规层次结构的一部分，但也链接在根级别维护的特殊"外来"优先级队列中。此外来优先级队列允许其他集群在其本地层次结构运行队列中的线程用完时，轻松地从不对称集群重新平衡线程。

## 总结

Apple 的 Clutch 和 Edge 调度器设计展示了如何在现代操作系统内核中实现高效的多核线程调度：

1. **分层调度架构**：通过调度桶、线程组和线程三层结构，实现了从全局到局部的精细化调度控制

2. **QoS 驱动的设计**：基于服务质量（Quality of Service）的调度策略，确保延迟敏感的工作负载（如 UI 交互）获得优先处理

3. **多集群优化**：Edge 调度器通过图模型管理线程在异构集群间的迁移，在性能和功耗之间取得平衡

4. **动态适应能力**：通过 WCEL、跃迁机制和交互性得分等创新设计，系统能够快速适应工作负载的变化

这套调度器设计不仅在 Apple 的自研芯片（如 M 系列芯片）上发挥了重要作用，其设计思想也对其他操作系统的调度器开发有重要参考价值。对于系统程序员和内核开发者来说，理解这套机制有助于更好地优化应用程序在 Apple 平台上的性能表现。
