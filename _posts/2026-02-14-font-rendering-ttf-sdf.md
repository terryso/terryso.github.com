---
layout: post
title: "深入理解字体渲染：从 TTF 解析到 SDF 光栅化"
date: 2026-02-14 09:25:28 +0800
categories: tech-translation
description: "本文探讨字体渲染的底层原理，从 TrueType 字体文件格式解析开始，到字形轮廓提取、光栅化算法，最终使用有符号距离场(SDF)技术实现高质量的跨分辨率字体渲染。"
original_url: https://mccloskeybr.com/articles/font_rendering.html
source: Hacker News
---

本文翻译自 [Font Rendering](https://mccloskeybr.com/articles/font_rendering.html)，原载于 Hacker News。

---

字体渲染是一项常常被我们视作理所当然的技术——很难想象没有它我们该如何与计算机交互。但这到底有多难？实际上，比你想象的要难得多：

* 文本可以以任意尺寸渲染。字体数据应该如何编码，才能让字形（glyph）在任何目标分辨率下都保持高质量？
* 字体通常是曲线的，而像素不是。我们应该如何对字形进行抗锯齿处理以保持文本的视觉美感？
* 我们应该如何设计一个尊重不同语言不同布局规则的系统（比如英语和阿拉伯语）？

看看 FreeType（GPL 许可，用于 Chromium、GNU/Linux 等），他们声称有超过 20 万行代码。

我决定自己动手实现一个。在这篇文章中，我将提供 TTF 文件规范的高级概述以及我的实现方案。但首先，为什么不直接使用 FreeType 或其他类似的库呢？自己从头实现有什么好处？

* 对支撑我们使用互联网等的基础技术产生更深的敬意。没有它，你现在就无法阅读这篇文章。
* 建立对渲染网页/GUI 所需工作量的直觉。为什么字体缓存很重要？我们如何降低渲染时间？
* 对基础知识的良好理解能够解锁进一步扩展的能力。例如通过 SDF 添加程序化边框。
* 这很有趣，为什么不呢？我们是娱乐编程的粉丝。

## TTF 文件格式

在我们开始渲染字符串之前，首先需要读入字体数据。我的实现专注于 TTF（TrueType）文件格式。另一种常用的格式 OTF（OpenType）可以被视为 TTF 的超集（还包括 PostScript 字体），所以如果你想渲染 OTF 字体，无论如何都需要先做一个 TTF 解析器。有很多字体是用 TTF 而非 OTF 表达的，当然足以覆盖我的初始用例（拉丁字母数字字形），所以我怀疑我不会很快将实现扩展到 OTF。

从高层次来看，TTF 文件提供了字符码点到字形信息的某种映射。

### 什么是码点（codepoint）？

字符的「码点」指的是它的 Unicode 编码格式。你可能熟悉 ASCII 编码，它是拉丁字母表中每个字符的单字节表示（例如，字符 'A' 映射到 65，'z' 映射到 122 等）。ASCII 的一个主要限制是它没有提供足够的空间来描述非拉丁语言。Unicode 是针对这个问题的国际采用解决方案。Unicode 有各种编码格式，例如 UTF-8 和 UTF-32；它们唯一的区别是如何编码这个码点（UTF-32 总是使用 4 字节表示码点，UTF-8 使用可变长度）。方便的是，UTF-8 与 ASCII 向后兼容（感谢 Ken Thompson 和 Rob Pike）。由于我现在只专注于拉丁字母表，这意味着 'a' 的码点可以通过 `(uint8_t) ('a')` 获取。在[这里](https://unicode.org/standard/standard.html)阅读更多关于 Unicode 标准的内容。

### 什么是字形（glyph）？

字形只是字母和字符之上的一个抽象。TTF 文件不知道字母 'a' 是什么，它只是某个值（Unicode 码点）到关于该值的一些数据（字形）的不透明映射。这包括与之关联的实际点和曲线，以便我们可以绘制它，以及我们需要小心考虑的关于该字符的额外度量——拉丁字母表突出了为什么这些度量很重要，看看这张图片作为例子：

这里，同一个字符串被渲染了两次（下面：可读的字符串；上面：每个字形的纹理完全不透明）。观察字形之间的差异——中心如何相对于基线定位，字符之间添加了多少空间，所有这些都高度依赖于你尝试渲染的字体和字符。要了解更多，我建议查看 [FreeType 文档](https://freetype.org/freetype2/docs/glyphs/glyphs-3.html)。

回到 TTF 文件，你可以在[这里](https://developer.apple.com/fonts/TrueType-Reference-Manual/)找到参考手册。你会很快注意到整体文件格式本身并不是太复杂；有许多包含构成整个字体的单个字形不同信息的表。只有少数表是直接相关的：

* `glyf`：存储字形形状数据。
* `loca`：将字形索引映射到 `glyf` 表中的偏移量。
* `cmap`：将 Unicode 码点映射到字形索引。

从这里，我们可以开始描绘如何获取字体形状信息。对于我们想要渲染的每个字符：

1. 通过 `cmap` 表确定其字形索引。
2. 通过在 `loca` 表中查找其对应值来确定字形数据在文件中的位置。
3. 在 `glyf` 表中提取字体形状信息。

还有一些其他表有一些值得注意的有用信息：

* `head`：包含关于字体的全局信息。
* `maxp`：描述字体中某些参数的最大值（例如「这个字体包含多少个字形？」），这对边界检查很有用。
* `hhea`：包含关于水平字体的信息。这包含 `ascent` 和 `descent` 变量，用于确定字体的总垂直大小。
* `hmtx`：描述每个字形水平布局的表（例如字形的 `advance`）。
* `kern`：可选提供的描述字符对额外字距调整信息的表。

当然还有其他表供你根据用例进行检查（例如 `vhea` 和 `vmtx` 存在于垂直语言中）。TTF 文件规范的一个主要部分是指定将字体缩放到特定分辨率的指令——如果你计划只支持较小比例的位图渲染，这变得更加重要。我发现替代方法，即基于 SDF 的渲染，可以在不必处理规范这一部分的情况下实现高质量结果，所以我忽略了这些表。

这一步的主要挑战之一是验证你从 TTF 文件数据中读取的数据，因为我们是从一个不透明的二进制 blob 中读取（至少我不太习惯）。运行调试器是你的朋友。我还建议熟悉另一个已知良好的 TTF 解析器并在困难时期进行比较，我使用 [stb_truetype](https://github.com/nothings/stb/blob/master/stb_truetype.h) 用于此目的。

## 字形解析

很好，现在我们知道字形数据在哪里了，是时候解析它了。在[参考手册](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html)中跟进。

TTF 字形由一系列轮廓（contour）组成，这些轮廓本身被描述为一系列二次贝塞尔曲线。这些由 3 个点组成：起点、终点和「控制」点。贝塞尔曲线被正式定义为这些点的「线性组合」（`起点 -> 控制点 -> 终点`），其中，给定 `[0, 1]` 范围内的 `t`，计算点对之间的线性插值，递归地，直到坍缩到单点。例如，对于给定的 `t = 0.4`，我们在起点和控制点之间放置一个中间点 40% 的位置，在控制点和终点之间放置另一个中间点 40% 的位置，然后重复，在我们的中间点之间 40% 的位置放置最终的在曲线上的点。这对 0 和 1 之间的所有 t 值重复以创建最终曲线。这可能更容易可视化理解：

描述二次贝塞尔曲线的另一种方式是通过公式：`(((1-t)^2) * P_start) + (2(1 - t)t * P_control) + ((t^2) * P_end)`，其中，同样 `t` 在 `[0, 1]` 范围内（一旦你意识到这只是底层的普通二次方程，这并不那么难）。

回到链条上方，这些曲线被组合形成轮廓，轮廓被组合形成整体字形形状。作为例子，这里是描述 Consola 字体中字形 'B' 的轮廓，其中每个轮廓是不同的颜色（注意贝塞尔控制点用紫色着色）：

我们看到，在这种情况下，有 3 个独立的轮廓：一个用于「外壳」，两个用于从中切出的「孔」。TTF 规范要求这些类别的轮廓被单独定义——「外壳」轮廓点的顺序必须是顺时针的，「孔」轮廓点必须是逆时针的。我们稍后将在光栅化字形时使用此信息来知道我们何时进入或退出形状，所以在这里记一下很好。

TTF 将二次贝塞尔点存储在一组连续数组中，一旦解析，就会坍缩为一个非常简单的结构：

```c
struct GlyphPoint {
  B8 on_curve;  // 如果为 false，此点是控制点
  V2 position;  // 点的校正位置（最初作为与前一个点的增量提供）
};
```

接下来，我们需要解开 TTF 应用于我们点数据的一些压缩。有时，它会从流中省略点——我们需要把它们加回来。考虑预期的点流看起来像：`点（在曲线上）-> 点（不在曲线上）-> 点（在曲线上）-> 重复`。看看我们实际提供的数据流，我们经常遇到像 `点（不在曲线上）-> 点（不在曲线上）` 这样的情况——我们在这里做什么？在这些场景中，一个在曲线上的点被_暗示_位于这些不在曲线上点的中点，我们需要自己添加它。此外，规范很乐意给你像 `点（在曲线上）-> 点（在曲线上）` 这样的情况——这里没有任何技巧，这只是这两点之间的直线，这只是另一个需要注意的情况，与二次贝塞尔情况分开。

我选择建模的方式是将曲线描述如下：

```c
struct GlyphCurve {
  V2 point;    // 此曲线的起点
  V2 control;  // 控制点（对于直线情况，位于中点）
};
```

其中贝塞尔曲线的终点被暗示为轮廓中下一个贝塞尔曲线的起点。我选择通过在中点插入不必要的控制点将直线情况强制转换为此模型，以简化后续处理，你当然可以选择将这些情况分开并单独处理。

文件规范还描述了「复合字形」——这本质上是另一种压缩形式。某些字符包含在整个给定字体中常用的子字形（想想 'i' 和 'j' 上的点，或像 é 这样字符上的变音符号）——TTF 不是多次复制轮廓数据来覆盖所有字符，而是将它们定义为独立的字形，并指示你根据目标字符的相关性使用一组变换来合并它们。精确的变换计算在规范中有更详细的描述，但实际检索轮廓形状本身的困难部分如上所述被重用。

## 字形光栅化

有了形状，是时候进行光栅化了。算法大致如下：

1. **确定我们要光栅化到的位图的目标部分。**

   你可以为每个字符生成单独的位图，但生成一个包含所有字符的图集（atlas）并在稍后向 GPU 发出绘制调用时索引到它可能更高效/最优。这就是我所做的。因此，我们需要确定图集的哪个子部分来渲染字符位图。

2. **对于目标位图中的每一行（y 值），确定字形空间中的对应 y 值。**

   这可以通过两个空间之间的简单线性映射来完成。例如，我们知道目标位图的高度和字形的高度，所以，给定目标位图空间中的某个 y 值，字形空间中的对应 y 可以通过使用比例找到（`y / target_height = ??? / glyph_height`）。这里需要注意的一件事是我们想要从像素的中间测量，而不是顶部或底部。

3. **确定我们的 y 值在字形空间中轮廓的 x 交点。**

   这可以通过求解二次贝塞尔公式中的 `t` 来完成——在 `0 <= t <= 1` 的情况下，我们有一个交点（由于曲线链接在一起，我只检查 `0 <= t < 1` 的交点，因为 `Bezier_n(1) == Bezier_n+1(0)`）。注意！求解二次方程涉及除以某个变量值，这可能是 0——这些情况描述的是秘密为直线的贝塞尔曲线。对于这些情况，你应该改为检查线性交点。我早先强制将直线转换为二次贝塞尔表示的决定在这里工作得很好，因为无论如何我们都必须实现这个检查。

4. **对于每个交点，确定它是「进入」还是「离开」形状。**

   例如，考虑一条水平穿过字母 'A' 中孔的光线——这条线上有四个独立的交点。我们需要确定哪些交点集合构成形状的「入」和「出」。合理地认为，对于给定的线，我们应该总是有偶数个交点；对于每个入口，必须有一个出口。然而，实际上，由于浮点精度误差（和其他神秘魔法），这可能并不总是如此。

   这可以通过利用 TTF 规范中轮廓的描述方式来处理。如前所述，「外壳」必须顺时针定义，「孔」必须逆时针定义。因此，通过查看我们相交的贝塞尔曲线的导数，我们可以确定我们是否正在进入（y 值增加）或离开（y 值减少）形状。Apple 规范建议在我们遇到交点时累积一个运行的卷绕计数——这是通过根据我们是进入还是离开形状为我们遇到的每个交点 +/- 1 来实现的。当卷绕顺序 > 0 时，笔应该落下，我们应该绘制。否则，笔应该抬起。

5. **将交点转换到目标位图空间，并进行光栅化。**

   现在我们有了所需的所有信息，我们可以索引到我们的目标位图并根据每个 x 值是在形状内还是外来给它着色。

很好，我们完成了！结果看起来怎么样？

非常糟糕......为什么？据我所知，这发生有几个原因：

1. 缺乏抗锯齿（虽然，启用线性采样并不能挽救它...）。
2. TTF 字体有关于如何在各种大小下渲染位图的额外指令，我们现在有意忽略了。
3. 位图字体不能很好地缩放。

理想情况下，我们希望位图图集具有相对较小的点大小，以节省内存空间。然而，根据我的经验，只有当字体大小相对较高时，我们才能真正获得像样的结果（这里的例子渲染到 32 像素的大小，看起来仍然很糟糕）。

## SDF 字形渲染

我们有许多选项可以纠正我们次优的字体光栅（MSDF 是我考虑的另一个选项，你也可以看看子像素渲染）。我选择为字形生成 SDF，这很吸引人，因为作为对这里已经实现的内容的附加步骤，它相当直接（例如对于位图光栅化）。此外，SDF 字体可以很好地缩放到任意分辨率，这是一个合理的约束，例如在 3D 环境中渲染标志等（例如玩家可能任意接近正在渲染的字体的游戏）。我还发现 SDF 字体在 2D 场景中看起来也很合理（例如用于 UI、菜单等）。

但首先，SDF 到底是什么？它如何解决我们这里的问题？

SDF 代表「有符号距离场」（signed distance field）。SDF 可以被描述为任意形状的函数表示，用于确定到该形状边缘的距离（「有符号」来自这个值在形状内部为负，在形状外部为正）。对于字体渲染，我们不是为目标位图中的每个像素计算二进制的「这是在还是出」决定，而是确定从该像素到相反状态（绘制或未绘制）的最近点的距离。这沿着形状边缘提供了「内在性」的平滑渐变，我们可以利用这一点以及 GPU 快速高效地大规模插值值的能力，以比原始位图表示更高的分辨率范围渲染字体字符。要了解更多关于 SDF 的信息（以及它们如何更普遍地应用于 2/3D 形状），[Xor 的这篇文章](https://www.youtube.com/watch?v=PMltMdi1Wzg)是一个很好的起点。

这是字母 'B' 的 SDF。注意当我们沿着字母边缘延伸得更远时，字母周围有一个渐变——我们可以使用它来对原始位图进行抗锯齿处理。

根据 [Valve 关于该主题的论文](https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf)，要生成给定字形的 SDF：

1. **生成字形的位图。**

   这完全重用了我们之前实现的内容。

   根据我的经验，光栅化一个相对较大的位图在这里很重要，以便为后续步骤提供高级别的粒度。本质上，分辨率越高，后面的距离测量就越准确，从而产生更高质量的结果。由于生成 SDF 后不保留位图光栅，我们不需要支付那么高的内存成本来长期保持高分辨率位图光栅。我在这里默认位图字体高度为 64。

2. **与位图光栅化类似，我们需要确定在目标位图中的哪里放置 SDF 光栅。**

3. **对于 SDF 目标位图中的每个像素，我们需要确定原始位图中的哪个像素最近。**

   这与生成原始位图类似，但略有不同——在这种情况下，我们只需要映射目标位图 y 值（在这里，我们为每个像素都做）。

4. **对于目标 SDF 位图中的每个像素，确定到原始字形位图中相反状态像素的最近距离。**

   这可以通过选择一些「扩散因子」（内核大小）并在目标像素周围搜索该大小的正方形来完成。这个参数是可调的，我发现值 4 在这里是合理的。在没有找到开启像素的情况下，使用给定内核大小的最大可能距离。

5. **将距离映射到字节范围 [0, 255] 并将其保存到 SDF 图集。**

这里的一个警告是，生成的 SDF 位图不是用于单独渲染的——这些更好地被描述为每个候选字形 SDF 函数值的缓存。所以，我们需要额外的指令来将这些距离值转换为我们可以在屏幕上绘制的实际位图。我为此目的制作了一个着色器（OpenGL）。更有趣的是片段着色器：

```glsl
#version 330 core
uniform sampler2D atlas_image;
uniform vec3 text_color;
uniform float threshold;
uniform float smoothing;
in vec2 glyph_tex_coord;
out vec4 frag_color;

void main() {
  float dist = texture(atlas_image, glyph_tex_coord).r;
  float alpha = smoothstep(threshold - smoothing, threshold + smoothing, dist);
  frag_color = vec4(text_color, alpha);
}
```

你会看到我们为正在渲染的每个给定像素提取缓存的距离值，对其应用一些平滑步进来确定 alpha，在最终像素颜色中使用结果。简而言之，这确定了沿着 SDF 周围的「内在性」场的哪个距离我们实际上认为该字符的内外。这由 2 个参数控制，`threshold`，这是入/出的截止，和 `smoothing`，它在阈值值上应用一些逐渐过渡/模糊。

那么，这些结果看起来怎么样？

好多了。这与原始位图并排看起来怎么样？SDF 光栅还有缺陷吗？

这使用 100 的位图高度和 32 的 SDF 高度（缩放到各种渲染高度）。你可以看到，总的来说，SDF 在各个方面都比原始位图看起来更好。但是，我们开始看到在较大字体大小处出现一些不期望的伪影。这可以通过以更高分辨率渲染 SDF 图集来纠正，但这伴随着更高的相关内存成本，所以你要权衡利弊。

最后，结果看起来还不错。这是我使用此技术渲染一些 UI 小部件的例子：

我的完整实现可以在[这里](https://github.com/mccloskeybr/font_rendering)找到。

## 总结

通过这次从零开始实现字体渲染的旅程，我们探索了：

* **TTF 文件结构** - 理解 `cmap`、`loca`、`glyf` 等表如何协同工作将码点映射到形状
* **贝塞尔曲线解析** - 二次贝塞尔曲线如何描述字形轮廓，以及 TTF 的压缩技巧
* **扫描线光栅化** - 使用卷绕数算法确定像素是否在形状内部
* **SDF 渲染** - 利用距离场实现高质量、可缩放的字体渲染

如果你正在寻找更多关于学习如何自己实现字体渲染的资源，我推荐以下内容：

* Sebastian Lague 的视频：[Coding Adventure: Rendering Text](https://www.youtube.com/watch?v=SO83KQuiu44)
* Sphaerophoria 的视频系列：[这里](https://www.youtube.com/playlist?list=PLW3Zl3wyJwWNIsUUa9XdO3bGb0yQF3EPU)
* Tsoding 的视频：[Rasterizing Splines in C (from fundamentals)](https://www.youtube.com/watch?v=Y2kPFoTa4IQ)
* `stb_truetype` 实现：[这里](https://github.com/nothings/stb/blob/master/stb_truetype.h)

---

**译者注**：这篇文章提供了一个独特的学习视角——通过实际动手实现来理解字体渲染的底层原理。虽然在实际项目中我们通常会使用 FreeType 等成熟库，但理解这些基础知识对于图形编程、游戏开发和性能优化都非常有价值。SDF 技术不仅适用于字体渲染，在游戏开发中也广泛用于各种形状的渲染和碰撞检测。
