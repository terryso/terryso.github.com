---
layout: post
title: "用 Claude Code 构建 TUI：比想象中简单得多"
date: 2026-02-14 16:29:18 +0800
categories: tech-translation
description: "本文介绍如何利用 Claude Code 和 Charm 工具栈快速构建终端用户界面（TUI），分享从实际项目中总结的开发经验和最佳实践。"
original_url: https://hatchet.run/blog/tuis-are-easy-now
source: Hacker News
---

本文翻译自 [TUIs are easy now](https://hatchet.run/blog/tuis-are-easy-now)，原载于 Hacker News。

---

## 初识 Claude Code：从怀疑到信服

2025 年 5 月，当我第一次启动 Claude Code 时，心想：*嗯，挺有意思的。一个基于终端的编程代理……他们一定是在讨好开发者。*

但在前 30 分钟内，我就被说服了：这东西会大火。火到我们在 Hatchet 讨论是否应该围绕终端编程代理构建一条新的产品线。

最终我们没有这么做，但那次使用 Claude Code 的初体验一直让我印象深刻。事后看来，终端代理在开发者群体中会有极快的采用曲线，这似乎如此简单而显而易见。

也许你也有类似的感觉——你正在开发的工具应该有一个 TUI（Terminal User Interface，终端用户界面）。也许你一直想自己构建一个 TUI。或者你只是喜欢念 too-ee 这个发音。

我说：去做吧。这比我想象的要简单得多，尤其是配合 Claude Code 的一些巧妙用法。这可是来自一个怀疑者的说法。我们之前曾尝试过一次激进的前端代理优先重构，花了一周搭建，修了五周 bug，然后废弃了。

相比之下，这个 TUI 主要由 Claude Code 驱动，只用了几天就构建完成并发布了。你可以在这里查看在线演示。

对于所有想要开发 TUI 的开发者，我想分享一些让这个项目比类似项目简单得多的决策：一条构建成功 TUI 应用的"快乐路径"。

## 为什么要构建 TUI？

我一直想为 Hatchet 做一个 TUI。就像 k9s 那样，但用于任务和工作流运行。我不确定其他人是否觉得有用，我们甚至没有向社区正式宣布，但几天内我们就收到了用户非常积极的、主动的反馈。比如：

> 伙计们，Hatchet CLI 做得太棒了（尤其是 TUI！）它感觉比 UI 性能好太多了。

我喜欢这条评论，因为它道出了我热爱 TUI 的核心——它们就是*感觉*更易用，即使它使用与 UI 完全相同的 API。它们也与过去几年 Web 应用的趋势截然相反：TUI 是文本优先的、信息密集的，最重要的是，它们内嵌在你的代码中，避免了频繁的标签页切换。

由于我们的用户主要在 IDE 中开发 Hatchet 任务和持久化工作流（durable workflows），我们希望提供一种体验，让工作流可以从终端可视化和运行，而不是在代码和浏览器之间不断切换。

## 技术栈

让我们深入了解细节。每个前端应用都从技术栈开始：如今典型的是 React、`react-query`、Tailwind、ShadCN 和一些 Tanstack 库。

TUI 开发也有对应的库——而且它们都由同一家公司维护！我说的是 **Charm 技术栈**：如果你不熟悉，Charm 团队一直在构建一套非常令人愉悦的 TUI 库。我主要使用了 **Bubble Tea**、**Lip Gloss** 和 **Huh**。不要被这些库可爱的名字所迷惑——它们的文档非常完善，有大量示例。

虽然我发现用 Bubble Tea 和 Bubbles 之外的方式构建自定义组件稍微困难一些，但这肯定比构建像 Claude Code 内部使用的 React 渲染引擎要简单。

我最喜欢的部分之一是使用 Lip Gloss 和 Huh 主题，可以轻松地将样式以一致的方式应用到任何 TUI 元素。然后我在整个 Hatchet CLI 中复用了这个样式，而不仅仅是 TUI。例如，Hatchet CLI 中的大多数命令默认是交互式的，使用 Lip Gloss 主题的表单：

```
? Select a workflow run
  > workflow-run-abc123
    workflow-run-def456
    workflow-run-ghi789
```

## 测试

最重要的测试环节是 Claude Code：事实证明，基于终端的编程代理非常擅长驱动其他基于终端的工具。这意味着开发流程是这样的：构建一个组件或视图，编译你的 TUI，然后让 Claude Code 进行第一轮测试。

我在 Hacker News 上看到一条评论，说用 Claude Code 驱动 tmux 会话，使用 `tmux capture-pane` 存储渲染视图并测试确保它们看起来正确。这对进行第一轮测试非常有效，同时也确保了视图的持续增加能正确渲染（即使是相对简单的 4 个主要视图的 Hatchet TUI，但也包含至少 6 个其他替换视口的模态框）。

以下是 Claude Code 在驱动 tmux 会话时"看到"的内容：

```
┌─────────────────────────────────────────────────────────────┐
│ HATCHET - Workflow Runs                                     │
├─────────────────────────────────────────────────────────────┤
│ Name              Status    Duration    Created             │
│ ─────────────────────────────────────────────────────────── │
│ process-order     ✓         2.3s        2024-01-15 10:23   │
│ send-email        ✓         0.5s        2024-01-15 10:22   │
│ sync-inventory    ⏳         1.2s        2024-01-15 10:21   │
│                                                              │
│ [R] Refresh  [E] Events  [L] Logs  [Q] Quit                │
└─────────────────────────────────────────────────────────────┘
```

从历史上看，我对编程代理处理涉及 e2e 或前端测试功能时的最大挫败感是反馈循环。但这次不同：LLM 就是为在基于 ASCII 的环境中迭代而构建的。在 Claude Code 进行第一轮测试后，我手动测试了每个视图，并为关键部分编写了单元测试。经过几次迭代，TUI 达到了令人惊讶的稳定状态。迭代感觉是收敛的而不是发散的。

## 选择简单模式

当使用参考实现时，Claude Code 效率更高。我们的参考实现是现有的前端。所以我对 Claude Code 的大部分指令都引用了现有且非常具体的前端视图、组件或 hooks。我们的前端没有做什么疯狂的事情，我们尽量保持组件和视图简单，将业务逻辑和 API 调用卸载到各种 React hooks。这给了 Claude Code 一个非常清晰的边界分离：先构建业务逻辑，后构建视图。

我们还从使用 OpenAPI 规范生成服务器接口和 REST API 客户端中受益匪浅，这给了 Claude Code 一个简单的参考和自动生成的客户端来与我们的 API 交互。

我最初怀疑最难构建的组件是基于 DAG（有向无环图）的渲染器。作为背景，Hatchet 在编排器领域是独特的，它支持单任务、通过持久化任务实现的持久化执行（durable execution），以及基于 DAG 的执行。渲染 DAG 是一个难题，在我们的前端中被出色的 React Flow 抽象化了，它处理了正确渲染 DAG 和图形的大量复杂性：

*DAG view in the Hatchet UI*

将 React Flow 内部逻辑转换到 TUI 似乎不可行，所以我尝试了不同的方法。我经历了几次失败的迭代，让 Claude Code 构建它，然后决定深入研究。我在网上搜索现有的基于 ASCII 的图形渲染器，偶然发现了 [mermaid-ascii](https://github.com/AlexanderGrooff/mermaid-ascii)。我克隆了这个仓库，让 Claude Code 参考它，写了几段提示词，第一次尝试就得到了一个*可工作的* DAG 渲染器。

它还不是完美像素级别的，但正在接近。

```
┌───────────────────────────────────────────────────┐
│                   Workflow DAG                     │
├───────────────────────────────────────────────────┤
│                                                    │
│      ┌─────────────┐                              │
│      │   start     │                              │
│      └──────┬──────┘                              │
│             │                                      │
│      ┌──────▼──────┐                              │
│      │ fetch-data  │                              │
│      └──────┬──────┘                              │
│             │                                      │
│    ┌────────┴────────┐                            │
│    │                 │                             │
│ ┌──▼───┐         ┌───▼───┐                        │
│ │process│         │validate│                       │
│ │  -a   │         │       │                        │
│ └──┬───┘         └───┬───┘                        │
│    │                 │                             │
│    └────────┬────────┘                            │
│             │                                      │
│      ┌──────▼──────┐                              │
│      │   notify    │                              │
│      └─────────────┘                              │
│                                                    │
└───────────────────────────────────────────────────┘
```

## 最终结果

总的来说，这花了大约 2 天的努力。值得注意的是，这是我第一次感觉到使用 Claude Code 做一些非琐碎的事情比自己做得明显更快。之前提到的那个前端重构失败案例具有所有代理反模式的特征：极快地得到一个非常 promising 的东西，然后在一波复杂性和由微妙的 bug 叠加微妙 bug 导致的问题中迷失方向。一座纸牌屋。我们在一次艰难的事后复盘后回滚了前端更改。

这对我来说是一个巨大的转变：发布一个主要功能，在过去几周的激进使用中一直可靠地工作，而且是由编程代理驱动的。虽然我们暂时不会完全放飞自我地使用代理，但我们正在逐渐更多地使用它们，特别是对于非关键路径（如果你的 TUI 崩溃了，希望它不会让你的生产环境瘫痪。但这对你的队列系统来说可不是真的）。

也许这些经验对于更有经验的工程师来说有点无聊和直观：构建一个具有紧密反馈循环、模块化设计、适当规范、持续测试和部署的环境，等等。但我终于感觉自己进入了循环。

再次分享在线演示链接，很希望听到你的反馈！

---

## 关键要点

1. **TUI 开发比想象中简单** - 使用 Charm 技术栈（Bubble Tea、Lip Gloss、Huh）可以快速构建美观的终端界面
2. **Claude Code 是 TUI 开发的利器** - 终端代理天生适合驱动和测试终端应用，反馈循环紧密
3. **参考实现很重要** - 有现有的前端作为参考，让 Claude Code 的效率大幅提升
4. **善用现有工具** - 不要从零开始，寻找像 mermaid-ascii 这样的现有解决方案可以事半功倍
5. **渐进式采用代理** - 从非关键路径开始使用编程代理，逐步建立信心

对于想要提升开发者体验的团队来说，TUI 是一个值得考虑的方向——它让工具更贴近开发者的日常工作环境，减少上下文切换，提高效率。
